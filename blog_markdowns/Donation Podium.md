# Donation Podium | 29/11/24
`Hello World`!

So I suppose if I have a blog page I need to actually put content on it, so I'll start with the thing that actually encouraged me to make this in the first place, and that is the donation podium I've been working on for [reformationfundraising.com](https://reformationfundraising.com). As of right now, you can see the finished product on the website now, it's just hidden away and not resized or placed anywhere on the website, but once it is, I hope that it will encourage people to donate more, particularly those in the top places, in the spirit of friendly competition. You can see that raw finished podium [here](https://reformationfundraising.com/podium/), but you may struggle since it fills up the entire width of the page, so it's a little difficult to look at. That's fine though, because that's not how it will look when I'm done!

Anyways, the point of this blog is to explain how I got it to work, because it's surprisingly not as simple as it would originally seem to just show the top three numbers from a list. To start with, I had to actually *get* that list:

## Getting the Leaderboard Data
This stage was split into two substages of a sort, although the first of them was admittedly trivial, it was just copy-pasting the data from the archives I had already saved, all but 2021 anyways, but that's a story for another day. So I just copied that into a Google Sheet.

The next stage was getting the data that didn't exist yet into the sheet, that is, creating a process for new donations to the 2025 campaign to record onto the sheet. Last year I would have had to use my webscraping application to get that live information because GoFundMe doesn't have an API I can pull from, but luckily this year we have been able to return to Tiltify, which *does* have an API (Thank god.). So, I was able to set up a Python Flask application to listen for new donations from a Tiltify Webhook, the tricky part here of course though is that webhooks require a public IP to notify, and of course my PC is not open to the internet, and regardless, `localhost` is not secure, which Tiltify requires. What I had to do then was forward it to a website I own which *is* secure, luckily enough for me, I have two of those, and you're on one of them to read this blog. This meant that I was able to select [lordimass.net](https://lordimass.net) as the endpoint for the webhook, and use CloudFlare to implement a webhook tunnel from a subdomain of [lordimass.net](https://lordimass.net) (I used [tiltify.lordimass.net](https://tiltify.lordimass.net) for clarity) to a port on my computer.

Now that I had that set up, the socket would recieve data any time I sent a test packet from Tiltify's end, meaning it was successfully functioning! Now that I had that raw data I had to actually process it, then get it sent off to the Google Sheet. To do this, I need to have a Python Flask application running on my computer at all times that a donation could come in. Luckily for me, 99% (SOURCE: I made it up) of the donations come in *during* the stream, so I can just have this code running in the background during the stream to pick everyhing up. Any of those odd couple of donations that come in before the stream, I  can just enter manually with no issues. Anyways, I formatted my code in three classes, a `FlaskApplication` and a `GSheetApplication` with a sort of middleman/helper class `DataHandler`, relatively simply, I got the `FlaskApplication` to listen out for new donations, push them to a queue on the `DataHandler`, which would then start a thread each time one came in to allow it to process each donation. Processing involved extracting the name, donation quantity, and comment (if there was one) from the donation, which is potentially surprisingly not the only information provided if you've never played with an API or webhook before, it actually comes with many more things like a donation ID, time, any rewards they may have claimed with it, etc. Once the DataHandler has this, it then passes it on to the `GSheetApplication`, which interacts with the Google API to put the data into a Google Sheet. You can access the python code from the GitHub Repository [here](https://github.com/Lordimass/tiltify-grabber). The Google Sheet is also publically accessibly but I'll leave that as a little treasure hunt for you, see if you can find it by digging around on [reformationfundraising.com](https://reformationfundraising.com), the SheetID is in there somewhere :D.

You may be asking what sort of mad person uses *Google Sheets* to store data for a website, instead of just storing it on the server the the site is hosted on, and the answer to that question is me. But I do actually have a valid line of reasoning for doing that, you see, both [reformationfundraising.com](https://reformationfundraising.com) and [lordimass.net](https://lordimass.net) are hosted using GitHub Pages, which is a service that allows you to host websites on their servers completely free of charge, saving us *a lot* of money. The only catch here (because of course there's a catch, don't be na√Øve) is that there is no ability for Dynamic Content, that means no storing data for the website on their servers. That means that I needed to find some publicly accessible place to store this data, and well... Google Sheets is just that. And also, as an added bonus, it also does the processing to find the top three donors as well, so I don't need to do that in JavaScript or Python, which would be much more complicated, although definitely possible.

So to recap, at this stage we now have a live updating Google Sheet which shows the donors in order of how much they've donated in total since 2020.

## Generating the Podium
Now I had no choice but to move to scripting in JavaScript in order to have the podium update on the website. Any time the page is loaded, the script runs to call on the Google Sheets API again, but this time in the reverse direction. A request is placed to read the data from the sheet, which then has the top three extracted. With those top three, I manipulated an inlined-SVG image to change the `innerText` values of the text elements I needed to update. These were updated from default values like `QUANT` (which you can still see if you have a sharp eye when reloading the page) to the true values for the top three most honourable donors to each of our causes.

This stage sounds a lot simpler than it was, mostly because it is actually really simple. I say this because it took me *forever* to get done due to struggles with not knowing how to manipulate SVGs. I was originally attempting to use an actual file called `podium.svg`, before I came to the realisation that since it's a file, it's not going to be manipulatable because that would be Dynamic Content (among other issues), which we discussed before is not possible with GitHub. Instead, I had to inline the SVG, that means I copied the raw text of the image (yes, SVGs are encoded with text, specifically an XML format just like HTML) so that it could be changed as HTML DOM elements just like anything else. On top of this issue, I also had to solve an issue of my special font, Omnes Pro, not showing up properly on systems where the font wasn't installed. The solution to this was actually found in parallel to the dynamic SVG one: Once I had inlined the SVG, I was able to apply CSS to it in order to style it, and that means that I could just use the CSS to apply the font to all the elements that needed it. If you understand web development at all, you can probably tell that none of this was particularly complicated, unfortunately I don't have that much experience with webdev yet, having only really started earlier this year when I reprogrammed [reformationfundraising.com](https://reformationfundraising.com) to escape SquareSpace's tyranny. 

## Conclusion
And that's the full story, simple, right? (/j)

Jokes aside, [the end result](https://reformationfundraising.com/podium/) is something I am very happy with. It also gave me a whole world of different skills that I can apply in other situations in order to get around that pesky dynamic content restriction. I could, for example, track a view count on each blog page, or create a comments section for arguing about what I've said. The possibilities are endless! Anyways, if you read all the way to the end of this very first blog, thank you very much for reading, it means a lot to me that you care about my ramblings regardless of who you are. Until I get something better set up, I encourage you to follow me on BlueSky [@lordimass.net](https://bsky.app/profile/lordimass.net), I plan on just posting whenever I write a new blog, and you can keep up to date with my smaller ramblings there too.

For now, `Goodbye World`!
